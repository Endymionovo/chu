<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Christmas Magic | Ultimate Edition</title>
    
    <!-- 1. 基础编译库 -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- 2. MediaPipe (全局加载模式) -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body, html { margin: 0; padding: 0; background-color: #020202; overflow: hidden; font-family: 'Helvetica Neue', sans-serif; touch-action: none; }
        #root { width: 100vw; height: 100vh; }
        
        /* Loading Overlay */
        #static-loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 99999; display: flex; flex-direction: column;
            align-items: center; justify-content: center; transition: opacity 0.8s ease-out;
        }
        .spinner { 
            width: 50px; height: 50px; 
            border: 2px solid rgba(255, 215, 0, 0.1); 
            border-top: 2px solid #FFD700; 
            border-radius: 50%; animation: spin 1s linear infinite; 
            margin-bottom: 20px;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.2);
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* UI Layer */
        .ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; display: flex; flex-direction: column; justify-content: space-between; }
        
        .header { text-align: center; padding-top: 6vh; pointer-events: auto; }
        .title {
            font-family: 'Times New Roman', serif;
            font-size: clamp(2rem, 5vw, 4.5rem); margin: 0; font-weight: 300; letter-spacing: 0.15em;
            background: linear-gradient(180deg, #fff 20%, #FFD700 100%); 
            -webkit-background-clip: text; color: transparent;
            filter: drop-shadow(0 0 15px rgba(255, 215, 0, 0.5));
            animation: pulseGlow 3s infinite alternate;
        }
        @keyframes pulseGlow { from { filter: drop-shadow(0 0 10px rgba(255,215,0,0.3)); } to { filter: drop-shadow(0 0 25px rgba(255,215,0,0.8)); } }

        /* Controls */
        .controls { padding: 30px; display: flex; flex-direction: row; align-items: flex-end; gap: 30px; pointer-events: auto; }
        
        .monitor-box { 
            width: 140px; height: 105px; 
            background: rgba(10, 10, 10, 0.8); 
            border: 1px solid #333; 
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.8);
            position: relative; border-radius: 8px; overflow: hidden; 
            transform: scaleX(-1);
            transition: border-color 0.3s;
        }
        .monitor-box.active { border-color: #FFD700; box-shadow: 0 0 15px rgba(255, 215, 0, 0.2); }

        .cam-video { position: absolute; width: 100%; height: 100%; object-fit: cover; opacity: 0; z-index: -1; }
        .cam-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #000; }
        
        /* Status Badges */
        .status-panel { display: flex; flex-direction: column; gap: 10px; padding-bottom: 5px; }
        .status-badge {
            color: #444; font-size: 0.9rem; font-family: monospace; letter-spacing: 1px;
            display: flex; align-items: center; gap: 12px;
            padding: 8px 12px; border-radius: 4px; border-left: 3px solid transparent;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        .status-badge.active { background: linear-gradient(90deg, rgba(255,255,255,0.05), transparent); }
        .status-badge.active.explode { color: #00FFFF; border-left-color: #00FFFF; text-shadow: 0 0 10px rgba(0,255,255,0.5); transform: translateX(10px); }
        .status-badge.active.tree { color: #FFD700; border-left-color: #FFD700; text-shadow: 0 0 10px rgba(255,215,0,0.5); transform: translateX(10px); }
        
        /* Start Screen */
        .start-screen {
            position: absolute; inset: 0; z-index: 100; background: #000;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }
        .btn-start {
            margin-top: 50px; padding: 18px 50px; font-size: 1.2rem; letter-spacing: 4px; font-family: 'Times New Roman', serif;
            background: linear-gradient(45deg, #1a1a1a, #000); color: #FFD700; border: 1px solid #FFD700;
            cursor: pointer; text-transform: uppercase; transition: 0.4s;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.1);
        }
        .btn-start:hover { 
            background: #FFD700; color: #000; box-shadow: 0 0 60px rgba(255, 215, 0, 0.8); transform: scale(1.05); 
        }

        #debug-log { position: fixed; bottom: 0; left: 0; width: 100%; max-height: 100px; overflow-y: auto; background: rgba(0,0,0,0.9); color: #ff5555; font-size: 10px; padding: 5px; z-index: 10000; display: none; }
        
        @media (max-width: 600px) {
            .controls { flex-direction: column-reverse; align-items: center; padding-bottom: 60px; }
            .monitor-box { width: 120px; height: 90px; }
            .title { font-size: 2.8rem; }
        }
    </style>

    <script type="importmap">
    {
        "imports": {
            "react": "https://esm.sh/react@18.2.0",
            "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
            "three": "https://esm.sh/three@0.160.0",
            "three/addons/": "https://esm.sh/three@0.160.0/examples/jsm/"
        }
    }
    </script>
</head>
<body>
    <div id="static-loader">
        <div class="spinner"></div>
        <div style="color: #666; font-size: 10px; letter-spacing: 3px;">LOADING EXPERIENCE</div>
    </div>
    <div id="debug-log"></div>
    <div id="root"></div>

    <script>
        window.onerror = function(msg, url, line) {
            const el = document.getElementById('debug-log');
            el.style.display = 'block';
            el.innerHTML += `<div>> ${msg} (${line})</div>`;
            document.getElementById('static-loader').style.display = 'none';
        };
    </script>

    <script type="text/babel" data-type="module">
        import React, { useState, useEffect, useRef } from 'react';
        import { createRoot } from 'react-dom/client';
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        const MediaPipeHands = window.Hands;
        const MediaPipeCamera = window.Camera;

        const App = () => {
            const [hasStarted, setHasStarted] = useState(false);
            const [gesture, setGesture] = useState('explode'); 
            const [debugText, setDebugText] = useState('');
            
            const containerRef = useRef(null);
            const videoRef = useRef(null);
            const canvasRef = useRef(null);
            
            // Refs for animation
            const sceneRef = useRef(null);
            const gestureRef = useRef('explode');

            useEffect(() => { gestureRef.current = gesture; }, [gesture]);

            // Remove Loader
            useEffect(() => {
                const loader = document.getElementById('static-loader');
                if(loader) {
                    loader.style.opacity = '0';
                    setTimeout(() => loader.style.display = 'none', 800);
                }
            }, []);

            // --- 3D Engine Setup ---
            useEffect(() => {
                if (!hasStarted || !containerRef.current) return;

                const scene = new THREE.Scene();
                scene.background = new THREE.Color(0x020202);
                scene.fog = new THREE.FogExp2(0x020202, 0.025);
                
                const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
                camera.position.set(0, 0, 18);

                const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance", stencil: false, depth: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                containerRef.current.appendChild(renderer.domElement);

                // HIGH-END POST PROCESSING (GLOW)
                const renderScene = new RenderPass(scene, camera);
                const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
                bloomPass.strength = 2.2; // 强烈的发光
                bloomPass.radius = 0.6;
                bloomPass.threshold = 0.1;

                const composer = new EffectComposer(renderer);
                composer.addPass(renderScene);
                composer.addPass(bloomPass);

                // --- 粒子系统核心 (Particle System) ---
                const PARTICLE_COUNT = 3000;
                // 使用八面体（像宝石切面）代替方块，反光更好看
                const geometry = new THREE.OctahedronGeometry(0.12, 0); 
                const material = new THREE.MeshBasicMaterial({ color: 0xffffff });
                const mesh = new THREE.InstancedMesh(geometry, material, PARTICLE_COUNT);
                
                const dummy = new THREE.Object3D();
                
                // 配色：深绿、翡翠、金、红、白
                const PALETTE = [
                    new THREE.Color(0x006400), // Dark Green
                    new THREE.Color(0x2E8B57), // Sea Green
                    new THREE.Color(0xFFD700), // Gold
                    new THREE.Color(0xDC143C), // Crimson
                    new THREE.Color(0xFFFFFF), // White
                    new THREE.Color(0x1E90FF)  // Sapphire (少许)
                ];

                const particles = [];

                for(let i=0; i<PARTICLE_COUNT; i++){
                    // 决定粒子的角色：大多数是树叶(绿)，少数是装饰(金/红)
                    const isOrnament = Math.random() > 0.7;
                    let color;
                    if(isOrnament) {
                        color = PALETTE[2 + Math.floor(Math.random() * 4)]; // Gold, Red, White, Blue
                    } else {
                        color = PALETTE[Math.floor(Math.random() * 2)]; // Greens
                    }
                    
                    mesh.setColorAt(i, color);

                    // 初始化位置 (大爆炸起始点)
                    const r = 30 * Math.cbrt(Math.random());
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    const x = r * Math.sin(phi) * Math.cos(theta);
                    const y = r * Math.sin(phi) * Math.sin(theta);
                    const z = r * Math.cos(phi);

                    particles.push({
                        // Physics properties
                        current: new THREE.Vector3(x, y, z),
                        target: new THREE.Vector3(x, y, z),
                        velocity: new THREE.Vector3(0, 0, 0),
                        
                        // Metadata
                        isOrnament: isOrnament,
                        baseScale: isOrnament ? 0.8 + Math.random()*0.5 : 0.4 + Math.random()*0.4,
                        twinkleSpeed: 2 + Math.random() * 5,
                        twinkleOffset: Math.random() * 100,
                        
                        // Tree Position (Pre-calculated)
                        treeIndex: i
                    });
                }
                scene.add(mesh);

                // --- 顶部大金星 ---
                const starGeo = new THREE.IcosahedronGeometry(1.2, 0);
                const starMat = new THREE.MeshBasicMaterial({ color: 0xFFD700 });
                const starMesh = new THREE.Mesh(starGeo, starMat);
                starMesh.position.set(0, 7.5, 0);
                starMesh.visible = false;
                scene.add(starMesh);

                // Resize
                const handleResize = () => {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);
                    composer.setSize(window.innerWidth, window.innerHeight);
                };
                window.addEventListener('resize', handleResize);

                // --- 物理动画循环 (Physics Loop) ---
                const clock = new THREE.Clock();
                
                const animate = () => {
                    requestAnimationFrame(animate);
                    const time = clock.getElapsedTime();
                    const mode = gestureRef.current;
                    const dt = 0.016; // Fixed step for stability

                    // 1. 更新大星星
                    if (mode === 'tree') {
                        if(!starMesh.visible) starMesh.visible = true;
                        starMesh.scale.lerp(new THREE.Vector3(1,1,1), 0.05);
                        starMesh.rotation.y += 0.02;
                        starMesh.rotation.z = Math.sin(time) * 0.1;
                    } else {
                        starMesh.scale.lerp(new THREE.Vector3(0,0,0), 0.1);
                        if(starMesh.scale.x < 0.01) starMesh.visible = false;
                    }

                    // 2. 计算每个粒子的目标位置
                    for(let i=0; i<PARTICLE_COUNT; i++){
                        const p = particles[i];
                        
                        if (mode === 'tree') {
                            // --- 真·圣诞树形态 ---
                            // 螺旋结构
                            const height = 15;
                            const ratio = i / PARTICLE_COUNT; // 0(bottom) -> 1(top)
                            
                            // 树形曲线：底部宽，顶部尖 (Parabolic or Linear fade)
                            const layer = Math.floor(ratio * 20); // 分层
                            const radiusBase = (1 - ratio) * 6.5; 
                            
                            // 增加随机性让树看起来茂密，而不是完美的几何体
                            const angle = i * 0.2 + time * 0.2; // 慢慢旋转
                            
                            let tx = Math.cos(angle) * radiusBase;
                            let ty = -6 + ratio * height;
                            let tz = Math.sin(angle) * radiusBase;

                            // 装饰物稍微往外飞一点
                            if(p.isOrnament) {
                                tx *= 1.1; 
                                tz *= 1.1;
                                ty += Math.sin(i)*0.2;
                            } else {
                                // 内部填充
                                const fill = Math.random();
                                if(fill > 0.8) {
                                    tx *= 0.6; tz *= 0.6;
                                }
                            }

                            p.target.set(tx, ty, tz);

                        } else {
                            // --- 极光星云形态 (Galaxy) ---
                            // 扁平的旋转星系，中心亮，四周暗
                            const angle = i * 0.02 + time * 0.1; // 旋转
                            const spiralOffset = (i % 5) * (Math.PI * 2 / 5);
                            
                            // 银河形状：由于i是线性的，我们用它做一个对数螺旋
                            const r = 2 + (i / PARTICLE_COUNT) * 12;
                            
                            // 增加波动
                            const waveY = Math.sin(r * 0.5 + time) * 1.5;
                            
                            const tx = Math.cos(angle + spiralOffset) * r;
                            const ty = waveY + (Math.random()-0.5) * 4; // 垂直散布
                            const tz = Math.sin(angle + spiralOffset) * r;
                            
                            p.target.set(tx, ty, tz);
                        }

                        // --- 物理引擎 (Physics Engine) ---
                        // F = ma. Spring force = (target - current) * stiffness
                        const stiffness = 0.05; // 弹性系数 (越小越软，越慢)
                        const damping = 0.92;   // 阻尼 (越小停得越快，越大越滑)

                        const forceX = (p.target.x - p.current.x) * stiffness;
                        const forceY = (p.target.y - p.current.y) * stiffness;
                        const forceZ = (p.target.z - p.current.z) * stiffness;

                        p.velocity.x += forceX;
                        p.velocity.y += forceY;
                        p.velocity.z += forceZ;

                        p.velocity.multiplyScalar(damping);

                        p.current.add(p.velocity);

                        // --- 渲染 ---
                        dummy.position.copy(p.current);
                        
                        // 闪烁特效 (Twinkle)
                        const s = p.baseScale + Math.sin(time * p.twinkleSpeed + p.twinkleOffset) * 0.15;
                        dummy.scale.setScalar(s);
                        
                        // 自身旋转
                        dummy.rotation.set(time + i, time * 0.5, 0);
                        
                        dummy.updateMatrix();
                        mesh.setMatrixAt(i, dummy.matrix);
                    }
                    mesh.instanceMatrix.needsUpdate = true;

                    // 摄像机微动 (Parallax)
                    const camX = Math.sin(time * 0.1) * 2;
                    const camY = Math.cos(time * 0.15) * 2;
                    camera.lookAt(0, 0, 0);
                    camera.position.x += (camX - camera.position.x) * 0.05;
                    camera.position.y += (camY - camera.position.y) * 0.05;

                    composer.render();
                };
                animate();

                return () => {
                    window.removeEventListener('resize', handleResize);
                    containerRef.current.innerHTML = '';
                    renderer.dispose();
                };
            }, [hasStarted]);

            // --- AI Logic (Improved) ---
            useEffect(() => {
                if(!hasStarted || !MediaPipeHands) return;

                const hands = new MediaPipeHands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
                hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6 });

                hands.onResults((results) => {
                    const ctx = canvasRef.current.getContext('2d');
                    ctx.fillStyle = "#000";
                    ctx.fillRect(0, 0, 320, 240);
                    
                    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                        const landmarks = results.multiHandLandmarks[0];
                        
                        // Draw Neon Skeleton
                        if(window.drawConnectors) window.drawConnectors(ctx, landmarks, window.HAND_CONNECTIONS, {color: '#00FFFF', lineWidth: 3});
                        if(window.drawLandmarks) window.drawLandmarks(ctx, landmarks, {color: '#FF00FF', lineWidth: 0, radius: 4});

                        // Robust Gesture Detection (Ratio based)
                        const wrist = landmarks[0];
                        const tips = [8, 12, 16, 20];
                        const knuckles = [5, 9, 13, 17];
                        let extended = 0;
                        
                        // Distance check
                        const dist = (p1, p2) => Math.hypot(p1.x - p2.x, p1.y - p2.y);
                        
                        for(let i=0; i<4; i++) {
                            if(dist(landmarks[tips[i]], wrist) > dist(landmarks[knuckles[i]], wrist) * 1.1) {
                                extended++;
                            }
                        }

                        if (extended <= 1) setGesture('tree');
                        else if (extended >= 3) setGesture('explode');
                    }
                });

                const camera = new MediaPipeCamera(videoRef.current, {
                    onFrame: async () => await hands.send({image: videoRef.current}),
                    width: 320, height: 240
                });
                
                camera.start().catch(e => setDebugText(e.message));

            }, [hasStarted]);

            return (
                <React.Fragment>
                    {!hasStarted ? (
                        <div className="start-screen">
                            <h1 className="title">CHRISTMAS</h1>
                            <p style={{color: '#888', letterSpacing: '2px', marginBottom: '30px', fontFamily:'monospace'}}>INTERACTIVE PARTICLE SYSTEM</p>
                            <button className="btn-start" onClick={() => setHasStarted(true)}>ENTER WORLD</button>
                        </div>
                    ) : (
                        <div className="ui-layer">
                            <div className="header">
                                <h1 className="title">MERRY CHRISTMAS</h1>
                            </div>
                            
                            <div className="controls">
                                <div className={`monitor-box ${gesture === 'tree' ? 'active' : ''}`}>
                                    <video ref={videoRef} className="cam-video" playsInline webkit-playsinline="true" muted></video>
                                    <canvas ref={canvasRef} className="cam-canvas" width="320" height="240"></canvas>
                                    <div style={{position:'absolute',top:5,left:8,color: gesture==='tree'?'#FFD700':'#00FFFF',fontSize:'10px',fontFamily:'monospace'}}>
                                        SYSTEM: {gesture === 'tree' ? 'CONVERGING' : 'EXPANDING'}
                                    </div>
                                    {debugText && <div style={{position:'absolute',bottom:5,left:5,color:'red',fontSize:'9px'}}>{debugText}</div>}
                                </div>
                                
                                <div className="status-panel">
                                    <div className={`status-badge explode ${gesture === 'explode' ? 'active' : ''}`}>
                                        NEBULA (OPEN)
                                    </div>
                                    <div className={`status-badge tree ${gesture === 'tree' ? 'active' : ''}`}>
                                        TREE (FIST)
                                    </div>
                                </div>
                            </div>
                        </div>
                    )}
                    <div ref={containerRef} style={{position:'absolute', top:0, left:0, zIndex:1}}></div>
                </React.Fragment>
            );
        };

        const root = createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>