<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Magical Christmas 3D</title>
    
    <style>
        body, html { margin: 0; padding: 0; background-color: #000; overflow: hidden; font-family: sans-serif; }
        #root { width: 100vw; height: 100vh; }
        
        /* 初始加载文字 */
        #static-loading {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #d4af37; font-size: 20px; text-align: center;
            z-index: 9999;
        }

        /* 错误提示框 */
        #error-log {
            position: fixed; bottom: 0; left: 0; width: 100%; background: rgba(50, 0, 0, 0.9);
            color: #ffcccc; padding: 10px; font-family: monospace; font-size: 12px;
            display: none; z-index: 10000; max-height: 200px; overflow: auto; border-top: 2px solid red;
        }

        /* UI Styles */
        .ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; z-index: 10; }
        .header { text-align: center; padding-top: 40px; pointer-events: auto; }
        .title {
            font-family: 'Times New Roman', serif; font-size: 3rem; margin: 0;
            background: linear-gradient(180deg, #fff, #FFD700); -webkit-background-clip: text; color: transparent;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.4);
        }
        .controls { padding: 30px; display: flex; align-items: flex-end; gap: 20px; pointer-events: auto; }
        .cam-box { width: 200px; height: 150px; background: #111; border: 1px solid #333; position: relative; border-radius: 8px; overflow: hidden; transform: scaleX(-1); }
        .cam-video { width: 100%; height: 100%; object-fit: cover; opacity: 0.5; }
        .cam-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        
        /* Start Screen */
        .start-screen {
            position: fixed; inset: 0; background: #000; z-index: 100; display: flex; flex-direction: column;
            align-items: center; justify-content: center; transition: opacity 0.8s;
        }
        .btn-start {
            margin-top: 30px; padding: 15px 40px; font-size: 1.2rem;
            background: transparent; color: #FFD700; border: 2px solid #FFD700;
            cursor: pointer; text-transform: uppercase; letter-spacing: 2px;
            transition: 0.3s; box-shadow: 0 0 15px rgba(255, 215, 0, 0.2);
        }
        .btn-start:hover { background: #FFD700; color: #000; box-shadow: 0 0 30px rgba(255, 215, 0, 0.6); }

        .status-badge {
            color: #555; font-weight: bold; margin-bottom: 5px; display: flex; align-items: center; gap: 10px;
        }
        .status-badge.active { color: #fff; text-shadow: 0 0 10px currentColor; }
        .dot { width: 10px; height: 10px; background: currentColor; border-radius: 50%; }
        .active .dot { box-shadow: 0 0 10px currentColor; }
    </style>

    <!-- Import Map -->
    <script type="importmap">
    {
        "imports": {
            "react": "https://esm.sh/react@18.2.0",
            "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
            "three": "https://esm.sh/three@0.160.0",
            "three/addons/": "https://esm.sh/three@0.160.0/examples/jsm/",
            "@mediapipe/hands": "https://esm.sh/@mediapipe/hands@0.4.1675469240",
            "@mediapipe/camera_utils": "https://esm.sh/@mediapipe/camera_utils@0.3.1675466862",
            "@mediapipe/drawing_utils": "https://esm.sh/@mediapipe/drawing_utils@0.3.1675466124"
        }
    }
    </script>
</head>
<body>
    <div id="static-loading">Initialize System...<br><span style="font-size:12px; opacity:0.6">Please wait for scripts to load</span></div>
    <div id="error-log"></div>
    <div id="root"></div>

    <script>
        // 全局错误捕获，如果黑屏会显示原因
        window.onerror = function(msg, url, line, col, error) {
            const div = document.getElementById('error-log');
            div.style.display = 'block';
            div.innerHTML += `<div>[Error] ${msg} <br> <small>${url}:${line}</small></div>`;
            document.getElementById('static-loading').style.display = 'none';
        };
    </script>

    <script type="module">
        import React, { useState, useEffect, useRef } from 'react';
        import { createRoot } from 'react-dom/client';
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { Hands } from '@mediapipe/hands';
        import { Camera } from '@mediapipe/camera_utils';
        import { drawConnectors, drawLandmarks } from '@mediapipe/drawing_utils';

        // 移除 loading 文字
        document.getElementById('static-loading').style.display = 'none';

        const App = () => {
            const [hasStarted, setHasStarted] = useState(false);
            const [gesture, setGesture] = useState('explode'); // 'explode' | 'tree'
            const [debugMsg, setDebugMsg] = useState('');
            
            const containerRef = useRef(null);
            const videoRef = useRef(null);
            const canvasRef = useRef(null);
            
            // Refs for Three.js animation
            const sceneRef = useRef(null);
            const particlesRef = useRef(null);
            const starRef = useRef(null);
            const gestureRef = useRef('explode');

            useEffect(() => { gestureRef.current = gesture; }, [gesture]);

            // 1. 初始化 Three.js
            useEffect(() => {
                if (!hasStarted || !containerRef.current) return;

                // Scene
                const scene = new THREE.Scene();
                scene.fog = new THREE.FogExp2(0x000000, 0.02);
                const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
                camera.position.z = 12;

                const renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                containerRef.current.appendChild(renderer.domElement);

                // Post Processing
                const renderScene = new RenderPass(scene, camera);
                const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
                bloomPass.strength = 2.0;
                bloomPass.radius = 0.5;
                bloomPass.threshold = 0;

                const composer = new EffectComposer(renderer);
                composer.addPass(renderScene);
                composer.addPass(bloomPass);

                // Particles
                const particleCount = 3000;
                const geometry = new THREE.BoxGeometry(0.15, 0.15, 0.15);
                const material = new THREE.MeshBasicMaterial({ color: 0xffffff });
                const mesh = new THREE.InstancedMesh(geometry, material, particleCount);
                
                const dummy = new THREE.Object3D();
                const colors = [0xFFD700, 0xC41E3A, 0x00FF00, 0x00BFFF];
                const particleData = [];

                for(let i=0; i<particleCount; i++){
                    dummy.position.random().subScalar(0.5).multiplyScalar(20);
                    dummy.updateMatrix();
                    mesh.setMatrixAt(i, dummy.matrix);
                    mesh.setColorAt(i, new THREE.Color(colors[Math.floor(Math.random()*colors.length)]));
                    
                    particleData.push({
                        x: dummy.position.x, y: dummy.position.y, z: dummy.position.z,
                        speed: 0.01 + Math.random() * 0.05,
                        angle: Math.random() * Math.PI * 2,
                        radius: 5 + Math.random() * 5
                    });
                }
                scene.add(mesh);
                particlesRef.current = mesh;

                // Star
                const starGeo = new THREE.OctahedronGeometry(1, 0);
                const starMat = new THREE.MeshBasicMaterial({ color: 0xFFD700 });
                const star = new THREE.Mesh(starGeo, starMat);
                star.position.set(0, 5, 0);
                star.visible = false;
                scene.add(star);
                starRef.current = star;

                // Resize
                const handleResize = () => {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);
                    composer.setSize(window.innerWidth, window.innerHeight);
                };
                window.addEventListener('resize', handleResize);

                // Loop
                const clock = new THREE.Clock();
                const animate = () => {
                    requestAnimationFrame(animate);
                    const time = clock.getElapsedTime();
                    const mode = gestureRef.current;

                    // Update Star
                    if(mode === 'tree') {
                        star.visible = true;
                        star.rotation.y += 0.02;
                        star.scale.lerp(new THREE.Vector3(1.5,1.5,1.5), 0.1);
                    } else {
                        star.scale.lerp(new THREE.Vector3(0,0,0), 0.1);
                        if(star.scale.x < 0.01) star.visible = false;
                    }

                    // Update Particles
                    for(let i=0; i<particleCount; i++){
                        const data = particleData[i];
                        
                        if (mode === 'tree') {
                            // Tree Logic (Cone Spiral)
                            const h = 10;
                            const ratio = i / particleCount;
                            const targetY = (ratio * h) - (h/2);
                            const r = (1 - ratio) * 4; // Cone radius
                            const angle = i * 0.5 + time;
                            
                            const tx = Math.cos(angle) * r;
                            const tz = Math.sin(angle) * r;
                            
                            dummy.position.x += (tx - dummy.position.x) * 0.05;
                            dummy.position.y += (targetY - dummy.position.y) * 0.05;
                            dummy.position.z += (tz - dummy.position.z) * 0.05;
                        } else {
                            // Explode Logic (Nebula)
                            const tx = Math.sin(time * 0.5 + data.angle) * data.radius * 1.5;
                            const ty = Math.cos(time * 0.3 + data.angle) * data.radius;
                            const tz = Math.sin(time * 0.2 + i) * data.radius;

                            dummy.position.x += (tx - dummy.position.x) * 0.02;
                            dummy.position.y += (ty - dummy.position.y) * 0.02;
                            dummy.position.z += (tz - dummy.position.z) * 0.02;
                        }
                        
                        dummy.rotation.x += 0.01;
                        dummy.rotation.y += 0.01;
                        dummy.updateMatrix();
                        mesh.setMatrixAt(i, dummy.matrix);
                    }
                    mesh.instanceMatrix.needsUpdate = true;

                    composer.render();
                };
                animate();

                return () => {
                    window.removeEventListener('resize', handleResize);
                    containerRef.current.innerHTML = '';
                }
            }, [hasStarted]);

            // 2. 初始化 MediaPipe
            useEffect(() => {
                if(!hasStarted) return;

                const onResults = (results) => {
                    const ctx = canvasRef.current.getContext('2d');
                    ctx.save();
                    ctx.clearRect(0, 0, canvasRef.current.width, canvasRef.current.height);
                    
                    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                        const landmarks = results.multiHandLandmarks[0];
                        drawConnectors(ctx, landmarks, Hands.HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 2});
                        drawLandmarks(ctx, landmarks, {color: '#FF0000', lineWidth: 1});

                        // 简单的手势判断：指尖到手腕距离
                        const wrist = landmarks[0];
                        const tips = [8, 12, 16, 20]; // 食指、中指、无名指、小指
                        let openFingers = 0;
                        tips.forEach(tipIdx => {
                            const tip = landmarks[tipIdx];
                            const pip = landmarks[tipIdx - 2]; 
                            // 简单判定：指尖离手腕比指关节远
                            const dTip = Math.hypot(tip.x - wrist.x, tip.y - wrist.y);
                            const dPip = Math.hypot(pip.x - wrist.x, pip.y - wrist.y);
                            if (dTip > dPip) openFingers++;
                        });

                        if (openFingers <= 1) setGesture('tree');
                        else if (openFingers >= 3) setGesture('explode');
                    }
                    ctx.restore();
                };

                const hands = new Hands({locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
                }});

                hands.setOptions({
                    maxNumHands: 1,
                    modelComplexity: 1,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });
                hands.onResults(onResults);

                const camera = new Camera(videoRef.current, {
                    onFrame: async () => {
                        await hands.send({image: videoRef.current});
                    },
                    width: 320,
                    height: 240
                });
                
                camera.start().catch(err => {
                    setDebugMsg("Camera failed: " + err.message);
                });
                
                return () => { camera.stop(); }

            }, [hasStarted]);

            return (
                <>
                    {!hasStarted && (
                        <div className="start-screen">
                            <h1 className="title">MERRY CHRISTMAS</h1>
                            <button className="btn-start" onClick={() => setHasStarted(true)}>
                                Enter Magic World
                            </button>
                            <p style={{color:'#666', marginTop:'20px'}}>
                                Requires Camera Access • Best viewed on Desktop
                            </p>
                        </div>
                    )}

                    <div className="ui-layer" style={{opacity: hasStarted ? 1 : 0}}>
                        <div className="header">
                            <h1 className="title">MERRY CHRISTMAS</h1>
                        </div>
                        
                        <div className="controls">
                            <div className="cam-box">
                                <video ref={videoRef} className="cam-video" playsInline></video>
                                <canvas ref={canvasRef} className="cam-canvas" width="320" height="240"></canvas>
                                {debugMsg && <div style={{position:'absolute',top:0,color:'red',fontSize:10}}>{debugMsg}</div>}
                            </div>
                            
                            <div>
                                <div className={`status-badge ${gesture === 'explode' ? 'active' : ''}`} style={{color: '#00BFFF'}}>
                                    <div className="dot"></div> EXPLODE (OPEN HAND)
                                </div>
                                <div className={`status-badge ${gesture === 'tree' ? 'active' : ''}`} style={{color: '#FFD700'}}>
                                    <div className="dot"></div> TREE (FIST)
                                </div>
                            </div>
                        </div>
                    </div>

                    <div ref={containerRef} style={{position:'absolute', top:0, left:0, zIndex:1}}></div>
                </>
            );
        };

        const root = createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>