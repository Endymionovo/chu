<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gesture Controlled 3D Photo Christmas Tree</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000510; font-family: 'Helvetica Neue', sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        
        /* UI Overlay */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10;
            display: flex; flex-direction: column; justify-content: space-between; padding: 20px; box-sizing: border-box;
        }

        .header {
            color: #ffd700; text-shadow: 0 0 10px #ffd700, 0 0 20px #c41e3a;
            text-align: center; margin-top: 10px;
        }
        h1 { margin: 0; font-weight: 300; letter-spacing: 5px; text-transform: uppercase; font-size: 24px; }
        .status { color: #87ceeb; font-size: 14px; margin-top: 5px; opacity: 0.8; }

        .controls {
            pointer-events: auto;
            background: rgba(0, 29, 61, 0.6);
            backdrop-filter: blur(10px);
            padding: 15px; border-radius: 12px; border: 1px solid rgba(255, 215, 0, 0.3);
            align-self: flex-start;
            max-width: 300px;
        }
        
        .upload-btn {
            background: linear-gradient(45deg, #c41e3a, #8a1226);
            color: white; border: none; padding: 10px 20px; border-radius: 20px; cursor: pointer;
            font-size: 14px; width: 100%; margin-bottom: 10px; transition: 0.3s;
            box-shadow: 0 0 15px rgba(196, 30, 58, 0.5);
        }
        .upload-btn:hover { transform: scale(1.05); box-shadow: 0 0 25px rgba(196, 30, 58, 0.8); }
        
        .instructions { color: #fff; font-size: 12px; line-height: 1.6; }
        .key-point { color: #ffd700; font-weight: bold; }

        /* Video element for MediaPipe (Hidden but active) */
        #input-video { position: absolute; width: 320px; height: 240px; top: 0; right: 0; visibility: hidden; }
        
        /* Debug/Preview of hand */
        #hand-preview {
            position: absolute; bottom: 20px; right: 20px; width: 200px; height: 150px; 
            border: 2px solid #ffd700; border-radius: 10px; opacity: 0.7; transform: scaleX(-1);
            z-index: 100; background: rgba(0,0,0,0.5);
        }

        /* Virtual Cursor */
        #cursor {
            position: absolute; width: 40px; height: 40px; border: 2px solid #ffd700; border-radius: 50%;
            transform: translate(-50%, -50%); pointer-events: none; display: none;
            box-shadow: 0 0 15px #ffd700, inset 0 0 10px #ffd700; transition: width 0.2s, height 0.2s;
            z-index: 20;
        }
        #cursor.pinching { background-color: rgba(255, 215, 0, 0.3); width: 30px; height: 30px; border-color: #c41e3a; box-shadow: 0 0 20px #c41e3a; }
        
        .loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: gold; font-size: 20px; }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div class="header">
            <h1>MERRY CHRISTMAS 3D</h1>
            <div class="status" id="status-text">ÂàùÂßãÂåñÁ≥ªÁªü...</div>
        </div>

        <div class="controls">
            <input type="file" id="photo-upload" accept="image/*" multiple style="display: none;">
            <button class="upload-btn" onclick="document.getElementById('photo-upload').click()">+ ‰∏ä‰º†ÁÖßÁâá (Âä†ÂÖ•ÁÖßÁâá‰∫ë)</button>
            <div class="instructions">
                <div>üëã <span class="key-point">‰∫îÊåáÂº†ÂºÄ</span>: Êï£ÂºÄÊºÇÊµÆ / ÁßªÂä®ËßÜËßí</div>
                <div>‚úä <span class="key-point">Êè°Êã≥</span>: ËÅöÂêàÊàêÂú£ËØûÊ†ë</div>
                <div>üëå <span class="key-point">ÊçèÂêàÊâãÊåá</span>: ÊäìÂèñÂπ∂ÊîæÂ§ßÁÖßÁâá</div>
            </div>
        </div>
    </div>

    <!-- Hand Tracking Preview Canvas -->
    <canvas id="hand-preview"></canvas>
    <!-- Virtual UI Cursor -->
    <div id="cursor"></div>
    
    <div id="canvas-container"></div>
    <video id="input-video"></video>
    <div id="loading" class="loading">Ê≠£Âú®Âä†ËΩΩ AI Ê®°Âûã‰∏é 3D ÂºïÊìé...</div>

    <!-- Import Maps for Three.js and MediaPipe -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
            "@mediapipe/hands": "https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/hands.js",
            "@mediapipe/camera_utils": "https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js",
            "@mediapipe/drawing_utils": "https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        
        // MediaPipe works best when loaded via script tag for the global object or managed carefully
        // Here we dynamically load the MediaPipe Scripts to ensure globals are available
        const loadScript = (src) => {
            return new Promise((resolve, reject) => {
                const s = document.createElement('script');
                s.src = src;
                s.onload = resolve;
                s.onerror = reject;
                s.crossOrigin = "anonymous";
                document.head.appendChild(s);
            });
        };

        // --- Configuration ---
        const CONFIG = {
            particleCount: 800,
            photoCount: 20, // Max initial placeholders
            treeHeight: 60,
            treeRadius: 25,
            colors: {
                gold: 0xFFD700,
                blue: 0x001D3D,
                red: 0xC41E3A,
                white: 0xFFFFFF
            },
            bloom: {
                threshold: 0,
                strength: 1.5,
                radius: 0.5
            }
        };

        // --- Global Variables ---
        let scene, camera, renderer, composer, controls;
        let particles = []; // Stores custom objects { mesh, treePos, scatterPos, type }
        let photoMeshGroup = new THREE.Group();
        let mainGroup = new THREE.Group(); // Holds everything for rotation
        
        // State
        const STATE = {
            ASSEMBLED: 'ASSEMBLED',
            SCATTERED: 'SCATTERED',
            FOCUSED: 'FOCUSED'
        };
        let currentState = STATE.ASSEMBLED;
        let targetState = STATE.ASSEMBLED;
        
        // Interaction
        let mouse = new THREE.Vector2();
        let raycaster = new THREE.Raycaster();
        let focusedObject = null;
        let handCursor = { x: 0, y: 0, active: false, pinching: false };
        let cameraTargetRot = { x: 0, y: 0 };

        // --- Initialization ---
        async function init() {
            // 1. Scene Setup
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000205); // Deep space blue/black
            scene.fog = new THREE.FogExp2(0x000205, 0.008);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 20, 90);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.toneMapping = THREE.ReinhardToneMapping;
            container.appendChild(renderer.domElement);

            // 2. Post Processing (Bloom)
            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = CONFIG.bloom.threshold;
            bloomPass.strength = CONFIG.bloom.strength;
            bloomPass.radius = CONFIG.bloom.radius;

            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            // 3. Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            
            const pointLight = new THREE.PointLight(CONFIG.colors.gold, 2, 100);
            pointLight.position.set(0, 30, 20);
            scene.add(pointLight);

            // 4. Create Content
            scene.add(mainGroup);
            mainGroup.add(photoMeshGroup);
            createParticles();
            createPhotoPlaceholders();

            // 5. Events
            window.addEventListener('resize', onWindowResize);
            
            // 6. MediaPipe Setup
            await setupMediaPipe();
            
            // 7. Start Loop
            document.getElementById('loading').style.display = 'none';
            animate();
        }

        // --- Content Generation ---

        function createParticles() {
            const geometrySphere = new THREE.SphereGeometry(0.5, 16, 16);
            const geometryBox = new THREE.BoxGeometry(0.8, 0.8, 0.8);
            
            const matGold = new THREE.MeshStandardMaterial({ 
                color: CONFIG.colors.gold, metalness: 0.8, roughness: 0.2, emissive: 0xaa6600, emissiveIntensity: 0.2 
            });
            const matRed = new THREE.MeshStandardMaterial({ 
                color: CONFIG.colors.red, metalness: 0.6, roughness: 0.3, emissive: 0x550000, emissiveIntensity: 0.3 
            });
            const matBlue = new THREE.MeshStandardMaterial({ 
                color: CONFIG.colors.blue, metalness: 0.5, roughness: 0.1, emissive: 0x001133, emissiveIntensity: 0.5 
            });

            // Generate particles
            for (let i = 0; i < CONFIG.particleCount; i++) {
                let mesh;
                const type = Math.random();
                
                if (type < 0.6) {
                    mesh = new THREE.Mesh(geometrySphere, Math.random() > 0.5 ? matGold : matRed);
                } else {
                    mesh = new THREE.Mesh(geometryBox, matBlue);
                }

                // Tree Position (Cone Spiral)
                const percent = i / CONFIG.particleCount;
                const angle = percent * Math.PI * 20; // 10 rounds
                const height = percent * CONFIG.treeHeight - (CONFIG.treeHeight/2);
                const radius = (1 - percent) * CONFIG.treeRadius;
                
                const treePos = new THREE.Vector3(
                    Math.cos(angle) * radius,
                    height,
                    Math.sin(angle) * radius
                );

                // Scatter Position (Random sphere)
                const scatterPos = new THREE.Vector3(
                    (Math.random() - 0.5) * 120,
                    (Math.random() - 0.5) * 120,
                    (Math.random() - 0.5) * 120
                );

                // Initial Pos
                mesh.position.copy(treePos);
                // Random scale variation
                const s = 0.5 + Math.random();
                mesh.scale.set(s,s,s);
                
                mainGroup.add(mesh);
                
                particles.push({
                    mesh: mesh,
                    treePos: treePos,
                    scatterPos: scatterPos,
                    originalScale: new THREE.Vector3(s,s,s),
                    isPhoto: false
                });
            }
        }

        function createPhotoPlaceholders() {
            const geo = new THREE.PlaneGeometry(6, 4.5); // 4:3 aspect
            
            for(let i=0; i<CONFIG.photoCount; i++) {
                // Create a canvas texture for placeholder
                const canvas = document.createElement('canvas');
                canvas.width = 256; canvas.height = 192;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = i % 2 === 0 ? '#C41E3A' : '#001D3D'; // Red or Blue bg
                ctx.fillRect(0,0,256,192);
                ctx.strokeStyle = '#FFD700';
                ctx.lineWidth = 10;
                ctx.strokeRect(0,0,256,192);
                ctx.fillStyle = '#FFD700';
                ctx.font = '30px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('PHOTO', 128, 90);
                ctx.fillText((i+1).toString(), 128, 120);

                const texture = new THREE.CanvasTexture(canvas);
                const mat = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide });
                const mesh = new THREE.Mesh(geo, mat);

                // Add gold border frame mesh
                const frameGeo = new THREE.BoxGeometry(6.2, 4.7, 0.2);
                const frameMat = new THREE.MeshStandardMaterial({ color: CONFIG.colors.gold, metalness: 1.0, roughness: 0.1 });
                const frame = new THREE.Mesh(frameGeo, frameMat);
                frame.position.z = -0.11;
                mesh.add(frame);

                // Positions
                const percent = Math.random(); 
                // Place photos more on the outer surface of tree
                const angle = percent * Math.PI * 16; 
                const height = (Math.random() - 0.5) * CONFIG.treeHeight;
                const radius = ((CONFIG.treeHeight/2 - height) / CONFIG.treeHeight) * CONFIG.treeRadius + 2; // Offset out

                const treePos = new THREE.Vector3(
                    Math.cos(angle) * radius,
                    height,
                    Math.sin(angle) * radius
                );
                
                const scatterPos = new THREE.Vector3(
                    (Math.random() - 0.5) * 100,
                    (Math.random() - 0.5) * 100,
                    (Math.random() - 0.5) * 100
                );

                mesh.position.copy(treePos);
                mesh.lookAt(0, height, 0); // Look at center spine
                
                mainGroup.add(mesh);
                particles.push({
                    mesh: mesh,
                    treePos: treePos,
                    scatterPos: scatterPos,
                    originalScale: new THREE.Vector3(1,1,1),
                    isPhoto: true,
                    targetLookAt: new THREE.Vector3(0, height, 0) // Used in tree mode
                });
            }
        }

        // --- Interaction Logic ---

        // Handle File Upload
        document.getElementById('photo-upload').addEventListener('change', function(e) {
            const files = Array.from(e.target.files);
            if(files.length === 0) return;

            // Update existing photo particles with new textures
            let fileIndex = 0;
            const photoParticles = particles.filter(p => p.isPhoto);
            
            files.forEach(file => {
                if(fileIndex >= photoParticles.length) return; // Limit reached

                const reader = new FileReader();
                reader.onload = function(event) {
                    const img = new Image();
                    img.src = event.target.result;
                    img.onload = () => {
                        const texture = new THREE.Texture(img);
                        texture.needsUpdate = true;
                        texture.colorSpace = THREE.SRGBColorSpace;
                        
                        // Update material
                        const p = photoParticles[fileIndex];
                        p.mesh.material.map = texture;
                        p.mesh.material.needsUpdate = true;
                        
                        // Fix aspect ratio
                        const aspect = img.width / img.height;
                        p.mesh.scale.set(1, 1/aspect * (4.5/6) * 1, 1); // rough adjust
                        
                        fileIndex++;
                    };
                };
                reader.readAsDataURL(file);
            });
            
            // Switch to scatter mode to show off upload
            targetState = STATE.SCATTERED;
            document.getElementById('status-text').innerText = "Áä∂ÊÄÅ: Êï£ÂºÄ (ÁÖßÁâáÂ∑≤‰∏ä‰º†)";
        });

        function updateParticles(dt) {
            const speed = 3.0 * dt;
            
            // Camera/Group Rotation logic
            if (currentState === STATE.SCATTERED) {
                // Gentle rotation
                mainGroup.rotation.y += 0.05 * dt;
                // Hand control rotation
                mainGroup.rotation.x += (cameraTargetRot.x - mainGroup.rotation.x) * dt;
                mainGroup.rotation.y += (cameraTargetRot.y - mainGroup.rotation.y) * dt;
            } else if (currentState === STATE.ASSEMBLED) {
                // Auto spin tree
                mainGroup.rotation.y += 0.3 * dt;
                // Reset X tilt
                mainGroup.rotation.x += (0 - mainGroup.rotation.x) * dt;
            }

            particles.forEach(p => {
                let target;
                
                if (currentState === STATE.ASSEMBLED) {
                    target = p.treePos;
                    // Reset orientation for photos in tree mode
                    if(p.isPhoto) {
                        p.mesh.lookAt(0, p.treePos.y, 0);
                        // Make tree pulsate slightly
                        const time = Date.now() * 0.001;
                        p.mesh.position.y = p.treePos.y + Math.sin(time + p.treePos.x)*0.5;
                    }
                } else if (currentState === STATE.SCATTERED || currentState === STATE.FOCUSED) {
                    target = p.scatterPos;
                    // Float effect
                    const time = Date.now() * 0.001;
                    p.mesh.position.y += Math.sin(time + p.scatterPos.x) * 0.02;
                }

                // Focus Logic
                if (currentState === STATE.FOCUSED && p === focusedObject) {
                    // Bring to front of camera
                    const focusPos = camera.position.clone().add(camera.getWorldDirection(new THREE.Vector3()).multiplyScalar(20));
                    p.mesh.position.lerp(focusPos, speed);
                    p.mesh.lookAt(camera.position);
                    p.mesh.scale.lerp(new THREE.Vector3(3,3,3), speed);
                } else {
                    // Normal movement
                    p.mesh.position.lerp(target, speed);
                    p.mesh.scale.lerp(p.originalScale, speed);
                    if(p.isPhoto && currentState !== STATE.ASSEMBLED) {
                         p.mesh.lookAt(camera.position); // Photos always face cam in scatter
                    }
                }
            });
        }

        // --- MediaPipe & Gesture Logic ---

        async function setupMediaPipe() {
            // Load libs first
            await loadScript("https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js");
            await loadScript("https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js");
            await loadScript("https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/hands.js");

            const videoElement = document.getElementById('input-video');
            const canvasElement = document.getElementById('hand-preview');
            const canvasCtx = canvasElement.getContext('2d');

            const hands = new window.Hands({locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/${file}`;
            }});

            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.7,
                minTrackingConfidence: 0.7
            });

            hands.onResults((results) => {
                // Draw Preview
                canvasCtx.save();
                canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
                canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);
                
                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    const landmarks = results.multiHandLandmarks[0];
                    window.drawConnectors(canvasCtx, landmarks, window.HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 2});
                    window.drawLandmarks(canvasCtx, landmarks, {color: '#FF0000', lineWidth: 1});
                    
                    processGesture(landmarks);
                } else {
                    handCursor.active = false;
                    resetIdleState();
                }
                canvasCtx.restore();
            });

            const cameraUtils = new window.Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({image: videoElement});
                },
                width: 320,
                height: 240
            });
            cameraUtils.start();
        }

        function processGesture(landmarks) {
            // 1. Detect Fingers Open/Closed
            const fingerTips = [8, 12, 16, 20];
            const fingerDips = [6, 10, 14, 18]; // Joints below tips
            let openFingers = 0;
            
            // Check 4 fingers (excluding thumb)
            fingerTips.forEach((tip, i) => {
                if (landmarks[tip].y < landmarks[fingerDips[i]].y) { // Y is inverted in MP logic sometimes, but usually 0 is top
                   openFingers++;
                }
            });
            
            // Thumb check (x based)
            // If thumb tip is further out than joint
            if (landmarks[4].x < landmarks[3].x && landmarks[4].x < landmarks[2].x) openFingers++; // Rough logic for right hand/mirrored

            // Better simple open/close detection:
            // Calculate bounding box of hand vs palm center
            // Simple Logic: Distance from wrist(0) to tips
            const wrist = landmarks[0];
            const tip9 = landmarks[9]; // Middle finger base
            const distScale = Math.hypot(wrist.x - tip9.x, wrist.y - tip9.y);
            
            let extendedCount = 0;
            [8,12,16,20].forEach(tip => {
                 if (Math.hypot(landmarks[tip].x - wrist.x, landmarks[tip].y - wrist.y) > distScale * 1.5) extendedCount++;
            });

            // 2. Detect Pinch (Thumb tip 4 and Index tip 8)
            const thumbTip = landmarks[4];
            const indexTip = landmarks[8];
            const pinchDist = Math.hypot(thumbTip.x - indexTip.x, thumbTip.y - indexTip.y);
            const isPinching = pinchDist < 0.05;

            // 3. Map Cursor Position (Index finger tip)
            // MediaPipe: x 0-1 (left-right), y 0-1 (top-bottom)
            // Flip X because webcam is mirrored
            const cursorX = (1 - indexTip.x) * window.innerWidth;
            const cursorY = indexTip.y * window.innerHeight;

            updateCursor(cursorX, cursorY, isPinching);

            // --- State Machine Logic ---
            const statusEl = document.getElementById('status-text');

            if (isPinching) {
                // Pinching -> Focus Mode (if hovering or just grab random)
                if (currentState === STATE.SCATTERED || currentState === STATE.FOCUSED) {
                    checkRaycastIntersection(cursorX, cursorY);
                }
            } else {
                // Release pinch -> Release focus if we were holding
                if (currentState === STATE.FOCUSED && !isPinching) {
                     targetState = STATE.SCATTERED;
                     focusedObject = null;
                }
                
                // General gestures
                if (extendedCount <= 1) {
                    targetState = STATE.ASSEMBLED;
                    statusEl.innerText = "Áä∂ÊÄÅ: Âú£ËØûÊ†ë (Êè°Êã≥)";
                } else if (extendedCount >= 4) {
                    targetState = STATE.SCATTERED;
                    statusEl.innerText = "Áä∂ÊÄÅ: Êï£ÂºÄ (‰∫îÊåáÂº†ÂºÄ)";
                    
                    // Rotation Control: Map hand center X/Y to rotation
                    const handCx = landmarks[9].x; 
                    const handCy = landmarks[9].y;
                    // Map 0.2-0.8 to -0.5 to 0.5 rad
                    cameraTargetRot.y = (handCx - 0.5) * 2; 
                    cameraTargetRot.x = (handCy - 0.5) * 2;
                }
            }
            
            currentState = targetState;
        }

        function updateCursor(x, y, pinching) {
            const cursor = document.getElementById('cursor');
            cursor.style.display = 'block';
            cursor.style.left = x + 'px';
            cursor.style.top = y + 'px';
            
            if(pinching) {
                cursor.classList.add('pinching');
                handCursor.pinching = true;
            } else {
                cursor.classList.remove('pinching');
                handCursor.pinching = false;
            }
        }

        function checkRaycastIntersection(x, y) {
            // Normalize for Three.js
            mouse.x = (x / window.innerWidth) * 2 - 1;
            mouse.y = -(y / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            // Intersect with photos only
            const photoMeshes = particles.filter(p => p.isPhoto).map(p => p.mesh);
            const intersects = raycaster.intersectObjects(photoMeshes);

            if (intersects.length > 0) {
                const hitMesh = intersects[0].object;
                const pObj = particles.find(p => p.mesh === hitMesh);
                if (pObj) {
                    focusedObject = pObj;
                    currentState = STATE.FOCUSED;
                    document.getElementById('status-text').innerText = "Áä∂ÊÄÅ: Êü•ÁúãÁÖßÁâá";
                }
            }
        }

        function resetIdleState() {
           // If hand lost, maybe just keep current state or drift?
           // keeping current state is better UX
           document.getElementById('cursor').style.display = 'none';
        }

        // --- Animation Loop ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta();
            
            updateParticles(dt);
            composer.render();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        // Run Init
        init();

    </script>
</body>
</html>